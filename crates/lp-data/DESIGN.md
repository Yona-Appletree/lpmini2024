# Design Document for lp-data Introspectable Data System

## Overview

This document addresses the design questions from NOTES.md and establishes the architecture for an introspectable data system that supports both static (compile-time) and dynamic (runtime) shapes, with ergonomic Rust APIs and efficient embedded memory usage.

## Core Concepts

- **LpKind**: Enumeration of basic data kinds (Fixed, Record)
- **LpShape**: Metadata describing the structure and properties of data
- **LpValue**: Trait that Rust types implement - values ARE the types, not wrappers
- **Shape Registry**: Optional registry for looking up shapes by identifier

## Key Insight

Rust structs like `LfoConfig` directly implement `LpValue` and `RecordValue` traits. They are not wrapped in an enum. The trait is the polymorphic interface.

## Design Decisions

### 1. Static vs Dynamic Shape Hierarchy

**Decision**: Use a unified trait-based hierarchy with separate concrete types for static and dynamic shapes (hybrid approach).

**Rationale**:

- Static shapes use `&'static str` for strings (zero-cost)
- Dynamic shapes use `String`
- Both implement common traits (`LpShape`, `RecordShape`) for polymorphic access
- Avoids duplication while maintaining performance for static cases
- We absolutely need dynamic shapes (some shapes aren't known at compile time)

**Implementation**:

- `LpShape` trait as the common interface
- `FixedShape` with optional metadata (static or dynamic)
- `RecordShapeStatic` with `&'static [RecordFieldStatic]`
- `RecordShapeDyn` with `Vec<RecordFieldDyn>` allocated through `lp_alloc`

### 2. Metadata Storage

**Decision**: Separate static and dynamic metadata types because strings are stored differently.

**Implementation**:

- `FixedMetaStatic` with `&'static str` for strings (e.g., unit: "ms")
- `FixedMetaDyn` with `String` for strings
- `RecordFieldMetaStatic` with `&'static str` for strings
- `RecordFieldMetaDyn` with `String` for strings
- Both static and dynamic shapes can have metadata (required for UI generation)

**Rationale**: Zero-cost for static shapes, consistent allocation for dynamic shapes.

### 3. Shape Lifecycle

**Decision**:

- Static shapes: Live for `'static` lifetime, no explicit management
- Dynamic shapes: Owned by lp-pool allocations, cleaned up when pool resets
- Values: Own their data, reference shapes (shapes outlive values)
- Field shape references: Use `&'static dyn LpShape` since static shapes cannot be deallocated

**Rationale**: Static shapes are compile-time constants. Dynamic shapes follow lp-pool lifecycle.

### 4. Value System Design

**Decision**:

- `LpValue` is a trait that concrete types implement
- Rust structs like `LfoConfig` implement `LpValue` and `RecordValue` directly
- No wrapper enum needed - the struct IS the value
- Codegen will generate `impl LpValue for LfoConfig` and `impl RecordValue for LfoConfig`

**Open Questions**:

- **Value Enum**: Do we need a companion enum `enum LpValueEnum { Fixed(Fixed), Record(...) }` for easier typing/pattern matching? Or is trait-only sufficient?
- **Value Storage**: For dynamic record values, how are fields stored?
  - All values boxed (`Vec<Box<dyn LpValue>>`)?
  - Direct ownership (enum of concrete value types)?
  - Hybrid (support references/pointers)?
  - How does this interplay with Rust's borrow checker?
- **Value Parameter Types**: What type should `set_field` accept?
  - Option A: `Box<dyn LpValue>` (owned)
  - Option B: `&dyn LpValue` (borrowed, requires cloning)
  - Option C: Generic `impl LpValue` (most flexible)

**Implementation**:

```rust
pub trait LpValue {
    fn shape(&self) -> &dyn LpShape;
}

pub trait RecordValue: LpValue {
    fn get_field(&self, name: &str) -> Result<&dyn LpValue, RuntimeError>;
    fn get_field_mut(&mut self, name: &str) -> Result<&mut dyn LpValue, RuntimeError>;
    fn set_field(&mut self, name: &str, value: ???) -> Result<(), RuntimeError>;
}

// Generated by codegen:
impl LpValue for LfoConfig { ... }
impl RecordValue for LfoConfig { ... }
```

### 5. Mutability Model

**Decision**: Values are mutable by default. Field access provides both `&` and `&mut` variants.

**Rationale**:

- Matches Rust's ownership model
- Allows in-place updates for performance
- Scripts can modify values directly

### 6. Shape Registry

**Decision**: Optional thread-local registry for dynamic shape lookup. Static shapes accessed directly via types.

**Rationale**:

- Dynamic shapes may need lookup by name/ID for scripts
- Static shapes don't need registry (accessed via Rust types)
- Registry is optional - can use direct references when possible

### 7. Future Extensibility (Lists, etc.)

**Decision**: Design traits to be extensible. Add `LpKind::List` and `ListShape` trait when needed.

**Rationale**: Current design focuses on Fixed and Record. Trait-based approach allows adding new kinds without breaking changes.

## Architecture

### Shape Hierarchy

```
LpShape (trait)
├── kind(&self) -> LpKind
└── (metadata access methods)

FixedShape (struct)
├── meta: Option<FixedMeta>  // Can be static or dynamic
└── impl LpShape

RecordShape (trait: LpShape)
├── field_count(&self) -> usize
├── get_field(&self, index: usize) -> Option<&dyn RecordFieldShape>
└── find_field(&self, name: &str) -> Option<&dyn RecordFieldShape>

RecordShapeStatic (struct)
├── name: &'static str
├── fields: &'static [RecordFieldStatic]
└── impl RecordShape

RecordShapeDyn (struct, allocated in lp-pool)
├── name: String
├── fields: Vec<RecordFieldDyn>
└── impl RecordShape
```

### Metadata Hierarchy

```
FixedMetaStatic
├── label: &'static str
├── desc_md: Option<&'static str>
└── unit: Option<&'static str>

FixedMetaDyn
├── label: String
├── desc_md: Option<String>
└── unit: Option<String>

RecordFieldMetaStatic
├── ui_hints: &'static [UiHint]
└── docs: Option<&'static str>

RecordFieldMetaDyn
├── ui_hints: Vec<UiHint>
└── docs: Option<String>
```

### Value Hierarchy

```
LpValue (trait)
├── shape(&self) -> &dyn LpShape
└── (implemented by concrete types)

RecordValue (trait: LpValue)
├── get_field(&self, name: &str) -> Result<&dyn LpValue, RuntimeError>
├── get_field_mut(&mut self, name: &str) -> Result<&mut dyn LpValue, RuntimeError>
└── set_field(&mut self, name: &str, value: ???) -> Result<(), RuntimeError>

// Concrete implementations:
impl LpValue for Fixed { ... }
impl LpValue for LfoConfig { ... }
impl RecordValue for LfoConfig { ... }

// Dynamic record value (TBD - see open questions)
struct RecordValueDyn { ... }
impl LpValue for RecordValueDyn { ... }
impl RecordValue for RecordValueDyn { ... }
```

### Field System

```
RecordFieldShape (trait)
├── name(&self) -> &str
├── shape(&self) -> &'static dyn LpShape
└── meta(&self) -> &RecordFieldMeta

RecordFieldStatic (struct)
├── name: &'static str
├── shape: &'static dyn LpShape
└── meta: RecordFieldMetaStatic

RecordFieldDyn (struct, allocated in lp-pool)
├── name: String
├── shape: &'static dyn LpShape
└── meta: RecordFieldMetaDyn
```

## File Structure

Following the compiler's type-based organization pattern:

```
crates/lp-data/src/kind/
  - mod.rs              // Module exports
  - kind.rs             // LpKind enum and related
  - shape.rs             // LpShape trait and related
  - value.rs             // LpValue trait and related

  - fixed/
    - mod.rs             // Module exports
    - fixed_schema.rs    // Types for Fixed, metadata, etc
    - fixed_dyn.rs       // Dynamic shapes for Fixed
    - fixed_static.rs    // Static shapes for Fixed
    - fixed_value.rs     // Value implementation for Fixed
    - fixed_tests.rs     // Integration tests for Fixed

  - record/
    - mod.rs             // Module exports
    - record_schema.rs   // Types for Record, metadata, etc
    - record_dyn.rs      // Dynamic shapes for Record
    - record_static.rs   // Static shapes for Record
    - record_value.rs    // Value implementation for Record
    - record_tests.rs    // Integration tests for Record
```

## Open Questions

### 1. Value Enum Design

Do we need a companion enum for `LpValue`?

- Option A: Trait-only (current approach)
- Option B: Trait + companion enum for pattern matching
- **Status**: Open - revisit after implementing trait-based approach

### 2. Dynamic Record Value Storage

How are fields stored in dynamic record values?

- Option A: `Vec<Box<dyn LpValue>>` (all boxed)
- Option B: Enum of concrete types (direct ownership)
- Option C: Hybrid (support references/pointers)
- **Status**: Open - need to understand borrow checker implications

### 3. Value Parameter Types

What type should `set_field` accept?

- Option A: `Box<dyn LpValue>` (owned)
- Option B: `&dyn LpValue` (borrowed, requires cloning)
- Option C: Generic `impl LpValue` (most flexible)
- **Status**: Open - depends on storage model

## Implementation Plan

1. Reorganize existing code into the new file structure
2. Define core traits (`LpShape`, `LpValue`, `RecordShape`, `RecordValue`) in `shape.rs` and `value.rs`
3. Move `LpKind` enum to `kind.rs`
4. Implement `FixedShape` with static and dynamic metadata support:
   - `fixed_schema.rs`: Metadata types (`FixedMetaStatic`, `FixedMetaDyn`)
   - `fixed_static.rs`: Static shape implementation
   - `fixed_dyn.rs`: Dynamic shape implementation
   - `fixed_value.rs`: `LpValue` implementation for `Fixed`
5. Implement record shapes:
   - `record_schema.rs`: Metadata types (`RecordFieldMetaStatic`, `RecordFieldMetaDyn`, `RecordFieldShape` trait)
   - `record_static.rs`: Static shape implementation (`RecordShapeStatic`, `RecordFieldStatic`)
   - `record_dyn.rs`: Dynamic shape implementation (`RecordShapeDyn`, `RecordFieldDyn`)
   - `record_value.rs`: `RecordValue` trait and implementations
6. Add integration tests in `fixed_tests.rs` and `record_tests.rs`
7. Implement codegen support for `#[derive(LpSchema)]` to generate `LpValue`/`RecordValue` impls (future)
8. Implement dynamic record values (address open questions)
9. Add shape registry (optional, for dynamic shapes)

## Memory Considerations

- Static shapes: Zero runtime cost (compile-time constants)
- Dynamic shapes: Allocated in lp-pool, follow pool lifecycle
- Values: Own their data, reference shapes (shapes outlive values)
- Strings: Static use `&'static str`, dynamic use `String`
- Field shape references: Use `&'static dyn LpShape` (static shapes never deallocated)

## Script Access

- Scripts access values via `LpValue` trait
- Field access by name for records
- Type checking via `shape().kind()`
- Efficient access patterns (no unnecessary allocations)

## UI Generation

- Shapes include metadata (`label`, `desc_md`, field-level UI hints like `slider(min, max, step)`)
- Metadata available at runtime for dynamic UI generation
- Static shapes have compile-time metadata
- Dynamic shapes have runtime metadata from lp-pool

## Trade-offs Analysis

### Static Shapes Pros

- No need for lp-pool to get shapes
- Faster startup since data is in program memory
- More memory efficient (zero runtime cost)
- Simple for a struct to know its shape (just a reference to a const)
- Type safety at compile time
- Zero-allocation startup
- Better codegen opportunities (match statements with compile-time constants)
- Embedded-friendly (no heap fragmentation)

### Static Shapes Cons

- Need separate code paths for static vs dynamic
- More complex trait hierarchy
- Can't create shapes at runtime from external data

### Dynamic Shapes Pros

- Simplicity: one hierarchy of shapes (if we went dynamic-only)
- Single source of truth for shapes, one registry
- Can create shapes from external data (JSON schemas, user-defined configs)
- Easier to serialize/deserialize shapes
- More flexible for runtime configuration

### Dynamic Shapes Cons

- Requires lp-pool allocation for all shapes
- Slower startup (need to allocate shapes)
- More memory usage (shapes in heap)
- Allocation can fail (need error handling)
- Less type-safe (shapes are runtime values)

### Hybrid Approach (Chosen)

- Combines benefits of both: zero-cost for static, flexibility for dynamic
- Complexity is localized to shape definitions
- Value system, script access, and UI generation work through traits (don't care about static vs dynamic)
- Best of both worlds for embedded environment
