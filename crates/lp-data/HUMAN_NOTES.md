# `lp-data` Design

**HUMAN OWNED FILE. AGENTS MUST NOT EDIT**

`lp-data` is a library for representing data used in the lightplayer runtime.

It is a runtime data engine that allows for dynamic access to data by scripts and other
dynamic updates.

A principle goal is being able to define data structures in Rust and use them in scripts and other
dynamic updates.

# Goals

## Rust ergonomics

Rust structs and enums should be the source of truth for most data structures. It should be ergonomic to define and use data structures in Rust code.

## Data-driven UI

The shapes in this system will be used to dynamically generate ui, and we must inclued inforation
necessary for the ui.

## Embedded environment

This data system is being used in an embedded environment, so we must be mindful of memory usage
and performance. `lp-pool` is a our custom allocator that we must use for all dynamic allocations.

## Script access

`lp-script` will be a primary consumer of this data system, so we must allow performant access
to the data from scripts.

# POC Goals

For the POC, I want:

- just two shapes: fixed point number (Fixed) and Record.
- define shapes in Rust and have the shape info generated at compile time.
- define shapes at runtime
- generate a zod schema for the data structures

# Design

The basic concepts are:

- `LpKind` basic kinds of data. Currently: `Fixed` and `Record`.
- `LpShape` some shape of data. Includes metadata.
- `LpValue` a wrapper around a value with reference to a shape.

Currently I think we need to have two separate hierarchies for shapes. One for static compile-time
shapes and one for dynamic runtime shapes. Though perhaps there is a way to have a single hierarchy.
It seems to have a single hierarchy, we would need to wait to instantiate the shapes until runtime
and when we have an lp-pool to allocate the shapes into.

## Questions

- How to handle strings from the static types
- How to handle other dynamic things like lists so we can have a trait that works for both static and dynamic shapes
- How to handle lifecycle of shapes and values
- How to handle mutablity: Can the data in a value be mutated, or must it be replaced with a new value?
- Should we separate shapes into static and dynamic variants? Is it worth the effort? If we don't, then we would likely need some kind of thread-local registry (though that may be neeed in any case).

## Static shapes

Most shapes in the system should be statically defined in Rust.
It should be ergonomic to define and use static shapes in Rust code.

```rust
#[derive(LpSchema)]
#[lp(schema(name = "LFO Config", docs = "Configuration for an LFO node."))]
pub struct LfoConfig {
    #[lp(field(
        ui(slider(min = 10, max = 60000, step = 1)),
        unit(ms)
        docs = "Oscillation period in milliseconds."
    ))]
    pub period_ms: LpInt32,
}
```

Codegen would generate implementations for getting schema information
at runtime.

If we have static shapes, it would look something like this:

```rust
// Generated by codegen.
const LFO_CONFIG_SHAPE = LpStaticRecordShape {
    name: "LFO Config",
    fields: [
        LpStaticRecordField {
            name: "period_ms",
            shape: LpStaticInt32Shape {
                meta: Int32Meta {
                    unit: "ms",
                },
            },
        },
    ],
};
impl StaticRecordValue for LfoConfig {
    fn shape(&self) -> &ShapeRef {
        &LFO_CONFIG_SHAPE
    }
    fn get_field(&self, name: &str) -> Result<&dyn LpValueTrait, RuntimeError> {
        match name {
            "period_ms" => Ok(&self.period_ms as &dyn LpValueTrait),
            _ => Err(RuntimeError::FieldNotFound {
                record_name: "LfoConfig",
                field_name: name,
            }),
        }
    }
}
```

## Dynamic shapes

Some data shapes cannot be known at compile time. For this, there are dynamic shapes.

```rust
let nodes = Lp
```

## Value system

The value system is the core of the data system. It is responsible for
representing data in the runtime.

It should be ergonomic to create and manipulate values in Rust code.

crates/lp-data/src/kind

- kind.rs // LpKind enum and related
- shape.rs // LpShape trait and related
- value.rs // Value trait and related
- fixed
  - fixed_schema.rs // Types for Fixed, metadata, etc
  - fixed_dyn.rs // Dynamic shapes for Fixed
  - fixed_static.rs // Static shapes for Fixed
  - fixed_value.rs // Value for Fixed
  - fixed_tests.rs // Integration tests for Fixed
- record
  - record_schema.rs // Types for Record, metadata, etc
  - record_dyn.rs // Dynamic shapes for Record
  - record_static.rs // Static shapes for Record
  - record_value.rs // Value for Record
  - record_tests.rs // Integration tests for Record
