# `lp-data` Design

`lp-data` is a library for representing data used in the lightplayer runtime.

## Goals

### Introspection

Structures should be introspectable at runtime for debugging and
for access by script and dynamic updates.

Static shapes should be introspectable at compile time to generate
a schema for the frontend.

### Static shapes

Most shapes in the system should be statically defined in Rust.
It should be ergonomic to define and use static shapes in Rust code.

```rust
#[derive(LpSchema)]
#[lp(schema(name = "LFO Config", docs = "Configuration for an LFO node."))]
pub struct LfoConfig {
    #[lp(field(
        ui(slider(min = 10, max = 60000, step = 1)),
        unit(ms)
        docs = "Oscillation period in milliseconds."
    ))]
    pub period_ms: LpInt32,
}
```

Codegen would generate implementations for getting schema information
at runtime.

```rust
// Generated by codegen.
const LFO_CONFIG_SHAPE = LpStaticRecordShape {
    name: "LFO Config",
    fields: [
        LpStaticRecordField {
            name: "period_ms",
            shape: LpStaticInt32Shape {
                meta: Int32Meta {
                    unit: "ms",
                },
            },
        },
    ],
};
impl StaticRecordValue for LfoConfig {
    fn shape(&self) -> &ShapeRef {
        &LFO_CONFIG_SHAPE
    }
    fn get_field(&self, name: &str) -> Result<&dyn LpValueTrait, RuntimeError> {
        match name {
            "period_ms" => Ok(&self.period_ms as &dyn LpValueTrait),
            _ => Err(RuntimeError::FieldNotFound {
                record_name: "LfoConfig",
                field_name: name,
            }),
        }
    }
}
```

### Dynamic shapes

Some data shapes cannot be known at compile time. For this, there are dynamic shapes.

```rust
let nodes = Lp
```

### Value system

The value system is the core of the data system. It is responsible for
representing data in the runtime.

It should be ergonomic to create and manipulate values in Rust code.
