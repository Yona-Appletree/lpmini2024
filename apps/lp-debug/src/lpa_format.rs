/// LPA (LightPlayer Assembly) format - human-readable assembly output
extern crate alloc;
use alloc::format;
use alloc::string::String;

use lp_script::shared::Type;
use lp_script::vm::opcodes::LpsOpCode;
use lp_script::vm::{FunctionDef, LpsProgram};

/// Convert a compiled program to LPA assembly format
pub fn program_to_lpa(program: &LpsProgram) -> String {
    let mut output = String::new();

    // Header
    output.push_str(&format!("; LPA Assembly - {}\n", program.name));
    output.push_str("; Generated by lps-compile\n\n");

    // Functions
    for (idx, func) in program.functions.iter().enumerate() {
        output.push_str(&function_to_lpa(func, idx, program));
        output.push('\n');
    }

    output
}

/// Convert a single function to LPA assembly
fn function_to_lpa(func: &FunctionDef, _func_idx: usize, program: &LpsProgram) -> String {
    let mut output = String::new();

    // Function header
    output.push_str(&format!(
        "function {} {}(",
        type_to_string(&func.return_type),
        func.name
    ));

    // Parameters
    for (i, param) in func.params.iter().enumerate() {
        if i > 0 {
            output.push_str(", ");
        }
        output.push_str(&format!("{} {}", type_to_string(&param.ty), param.name));
    }
    output.push_str(") {\n");

    // Locals
    if !func.locals.is_empty() {
        output.push_str("  ; Locals:\n");
        for local in &func.locals {
            output.push_str(&format!(
                "  ;   {} {}\n",
                type_to_string(&local.ty),
                local.name
            ));
        }
        output.push('\n');
    }

    // Opcodes
    for (pc, opcode) in func.opcodes.iter().enumerate() {
        output.push_str(&format!(
            "  {:04}  {}\n",
            pc,
            opcode_to_pretty_string(opcode, func, program)
        ));
    }

    output.push_str("}\n");
    output
}

/// Convert opcode to pretty assembly string
fn opcode_to_pretty_string(opcode: &LpsOpCode, func: &FunctionDef, program: &LpsProgram) -> String {
    use lp_script::vm::opcodes::LoadSource;

    match opcode {
        LpsOpCode::Push(fixed) => format!("push {}", fixed.to_f32()),

        LpsOpCode::Load(source) => {
            let source_name = match source {
                LoadSource::XNorm => "builtin.xNorm",
                LoadSource::YNorm => "builtin.yNorm",
                LoadSource::XInt => "builtin.xInt",
                LoadSource::YInt => "builtin.yInt",
                LoadSource::Time => "builtin.time",
                LoadSource::TimeNorm => "builtin.timeNorm",
                LoadSource::CenterDist => "builtin.centerDist",
                LoadSource::CenterAngle => "builtin.centerAngle",
            };
            format!("load {}", source_name)
        }

        LpsOpCode::LoadLocalFixed(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("load local.{}", local_name)
        }

        LpsOpCode::StoreLocalFixed(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("store local.{}", local_name)
        }

        LpsOpCode::LoadLocalVec2(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("load.vec2 local.{}", local_name)
        }

        LpsOpCode::StoreLocalVec2(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("store.vec2 local.{}", local_name)
        }

        LpsOpCode::LoadLocalVec3(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("load.vec3 local.{}", local_name)
        }

        LpsOpCode::StoreLocalVec3(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("store.vec3 local.{}", local_name)
        }

        LpsOpCode::LoadLocalVec4(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("load.vec4 local.{}", local_name)
        }

        LpsOpCode::StoreLocalVec4(idx) => {
            let local_name = func
                .locals
                .get(*idx as usize)
                .map(|l| l.name.as_str())
                .unwrap_or("?");
            format!("store.vec4 local.{}", local_name)
        }

        // Call with function index - resolve to function name
        LpsOpCode::Call(func_idx) => {
            let func_name = program
                .function(*func_idx as usize)
                .map(|f| f.name.as_str())
                .unwrap_or("?");
            format!("call {}", func_name)
        }

        LpsOpCode::Return => "return".to_string(),

        // Arithmetic
        LpsOpCode::AddFixed => "add".to_string(),
        LpsOpCode::SubFixed => "sub".to_string(),
        LpsOpCode::MulFixed => "mul".to_string(),
        LpsOpCode::DivFixed => "div".to_string(),
        LpsOpCode::NegFixed => "neg".to_string(),

        // Trig
        LpsOpCode::SinFixed => "sin".to_string(),
        LpsOpCode::CosFixed => "cos".to_string(),

        // Advanced
        LpsOpCode::SmoothstepFixed => "smoothstep".to_string(),
        LpsOpCode::FractFixed => "fract".to_string(),
        LpsOpCode::SaturateFixed => "saturate".to_string(),

        LpsOpCode::Perlin3(octaves) => format!("perlin3 octaves={}", octaves),

        // Vector ops
        LpsOpCode::MulVec2Scalar => "mul.vec2".to_string(),
        LpsOpCode::MulVec3Scalar => "mul.vec3".to_string(),
        LpsOpCode::MulVec4Scalar => "mul.vec4".to_string(),

        // For anything else, fall back to Debug
        _ => format!("{:?}", opcode).to_lowercase(),
    }
}

/// Convert type to string
fn type_to_string(ty: &Type) -> &'static str {
    match ty {
        Type::Fixed => "float",
        Type::Int32 => "int",
        Type::Vec2 => "vec2",
        Type::Vec3 => "vec3",
        Type::Vec4 => "vec4",
        Type::Void => "void",
        Type::Bool => "bool",
    }
}

#[cfg(test)]
mod tests {
    use lp_script::{parse_expr, parse_script};

    use super::*;

    #[test]
    fn test_simple_expr_to_lpa() {
        let program = parse_expr("xNorm + yNorm");
        let lpa = program_to_lpa(&program);

        // Should have header
        assert!(lpa.contains("; LPA Assembly"));
        assert!(lpa.contains("function float main"));

        // Should have pretty opcodes
        assert!(
            lpa.contains("load builtin.xNorm"),
            "Should have load builtin.xNorm"
        );
        assert!(
            lpa.contains("load builtin.yNorm"),
            "Should have load builtin.yNorm"
        );
        assert!(lpa.contains("add"), "Should have add instruction");
    }

    #[test]
    fn test_script_with_function_to_lpa() {
        let program = parse_script(
            "float add(float a, float b) { return a + b; } \
             return add(1.0, 2.0);",
        );
        let lpa = program_to_lpa(&program);

        // Should have both functions
        assert!(lpa.contains("function float add"));
        assert!(lpa.contains("function float main"));

        // Should show parameters
        assert!(lpa.contains("float a"));
        assert!(lpa.contains("float b"));
    }

    #[test]
    fn test_vec3_return_type_in_lpa() {
        let program = parse_script("return vec3(1.0, 0.5, 0.0);");
        let lpa = program_to_lpa(&program);

        // Should show vec3 return type
        assert!(
            lpa.contains("function vec3 main"),
            "LPA should show vec3 return type:\n{}",
            lpa
        );
    }

    #[test]
    fn test_locals_in_lpa() {
        let program = parse_script(
            "float x = 1.0; \
             float y = 2.0; \
             return x + y;",
        );
        let lpa = program_to_lpa(&program);

        // Should list locals in comments
        assert!(lpa.contains("; Locals:"));
    }

    #[test]
    fn test_fixed_values_as_floats() {
        // Use xNorm + constant to prevent constant folding
        let program = parse_expr("xNorm + 2.5");
        let lpa = program_to_lpa(&program);

        // Should show human-readable float 2.5, not raw fixed-point int
        assert!(lpa.contains("2.5"), "Should contain 2.5, got:\n{}", lpa);

        // Should NOT contain the raw fixed-point integer representation
        // 2.5 in fixed-point is 163840 (2.5 * 65536)
        assert!(
            !lpa.contains("Fixed(163840)"),
            "Should not show raw int 163840 for 2.5"
        );
        assert!(
            !lpa.contains("(163840)"),
            "Should not show raw int representation"
        );
    }

    #[test]
    fn test_pretty_assembly_format() {
        let program = parse_script(
            "float add(float a, float b) { return a + b; } \
             float x = 1.5; \
             return add(x, 2.0);",
        );
        let lpa = program_to_lpa(&program);

        // Should use lowercase instructions
        assert!(
            lpa.contains("push 1.5"),
            "Should have lowercase 'push', got:\n{}",
            lpa
        );
        assert!(
            lpa.contains("call add"),
            "Should have 'call add', got:\n{}",
            lpa
        );

        // Should use readable load sources
        assert!(
            lpa.contains("load builtin.time") || lpa.contains("load local."),
            "Should have readable load sources, got:\n{}",
            lpa
        );

        // Should not have ugly Debug format
        assert!(
            !lpa.contains("Push("),
            "Should not have Debug format Push()"
        );
        assert!(
            !lpa.contains("Call("),
            "Should not have Debug format Call()"
        );
    }

    #[test]
    fn test_pretty_builtin_loads() {
        let program = parse_expr("xNorm + yNorm + time");
        let lpa = program_to_lpa(&program);

        assert!(
            lpa.contains("load builtin.xNorm"),
            "Should show builtin.xNorm, got:\n{}",
            lpa
        );
        assert!(
            lpa.contains("load builtin.yNorm"),
            "Should show builtin.yNorm, got:\n{}",
            lpa
        );
        assert!(
            lpa.contains("load builtin.time"),
            "Should show builtin.time, got:\n{}",
            lpa
        );
    }
}
